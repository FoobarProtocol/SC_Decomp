import openai
from openai import OpenAI

client = OpenAI()


# Generated by CodiumAI


def program_Classifier(prompt, max_tokens=2560, stop=None, temperature=0):
    response = None
    while response is None:
        try:
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                temperature=temperature,
                response_format={
                    "type": "json_object"
                },
                messages=[
                    {
                        "role": "system",
                        "content": prompt
                    }
                ],
                max_tokens=max_tokens
            )
        except Exception as e:
            print(type(e), e)
            if str(type(e)) == "<class 'openai.error.InvalidRequestError'>":
                response = "null"

    if response == "null":
        return ["Error: Invalid request"]

    return [response.choices[0].message.content]


def gen_for_gpt3(input, query, OpenAIKey):
    client.api_key = OpenAIKey
    input_m = []
    for put in input:
        input_m.append(put[0])
    input_mes = ", ".join(input_m)
    prompt = (
        """You are an expert smart contract developer and prompt engineer tasked with analyzing and improving user-submitted prompts related to blockchain development. Your goal is to transform basic smart contract queries into comprehensive, security-focused instructions that yield robust and secure smart contracts.

Historical Context and Evolution of Smart Contract Development:
- Smart contracts emerged with Ethereum in 2015, revolutionizing blockchain programmability
- Security best practices evolved through lessons learned from major protocol hacks and vulnerabilities
- Modern smart contract development incorporates formal verification, automated testing, and standardized patterns

Prompt Analysis Framework for Smart Contract Development:
1. Security-First Intent Analysis
   - Identify potential security vulnerabilities and attack vectors
   - Understand gas optimization requirements
   - Consider cross-chain compatibility needs
   - Evaluate regulatory compliance requirements

2. Technical Context Enhancement
   - Specify Solidity version constraints
   - Define required ERC standards and interfaces
   - Establish upgrade patterns and governance mechanisms
   - Document external contract dependencies

3. Implementation Structuring
   - Define contract architecture and inheritance patterns
   - Specify state variables and access patterns
   - Detail function modifiers and visibility
   - Outline event emissions and indexing
   - Structure error handling and require statements

Given a user-submitted smart contract prompt, analyze it using this framework and generate an enhanced version that:
- Prioritizes security and gas optimization
- Includes specific guidance for common vulnerabilities
- Incorporates latest Solidity best practices
- Uses clear, standardized naming conventions
- Provides test cases and validation criteria
- Includes deployment and verification steps

Example Transformation:
ORIGINAL: Write a token contract Input: Token_Name
ENHANCED: Create a secure and gas-optimized ERC20 token contract for {{Token_Name}} with the following specifications:

1. Core Implementation
   - Use latest stable Solidity version (^0.8.0)
   - Implement OpenZeppelin's ERC20 standard
   - Include pausable and ownable functionality
   - Implement safe math operations

2. Security Features
   - Rate limiting for transfers
   - Blacklist functionality
   - Emergency pause mechanism
   - Reentrancy guards
   - Integer overflow protection

3. Gas Optimization
   - Efficient storage patterns
   - Minimal state changes
   - Optimized loop operations
   - Event emission strategy

4. Testing Requirements
   - Unit tests for all functions
   - Integration tests with other protocols
   - Gas usage benchmarks
   - Security vulnerability tests

5. Deployment Process
   - Network-specific configurations
   - Constructor parameters
   - Verification steps
   - Initial distribution plan

Format the implementation with clear documentation using NatSpec, maintain consistent error messages, and ensure all functions have explicit visibility modifiers. Include events for all significant state changes.

Now, analyze and enhance the following smart contract prompt:
PROMPT: """
        + query.strip()
        + """ Input: """
        + input_mes
        + """
ENHANCED PROMPT:"""
    )
    first = program_Classifier(prompt=prompt, max_tokens=2560, temperature=0.5)

    second = program_Classifier(prompt=prompt, max_tokens=2560, temperature=0.7)

    third = program_Classifier(prompt=prompt, max_tokens=2560, temperature=1)
    result = [first[0], second[0], third[0]]
    print("First: ", first[0])
    print("Second: ", second[0])
    print("Third: ", third[0])

    return result


# query = "According to the number of questions entered, generate math homework based on the math problem. "
# first, second, thrid = gen_for_gpt3(["Number"], query)

import pytest


class TestProgramClassifier:
    # Tests that the function returns a list of strings
    def test_happy_path_returns_list_of_strings(self):
        input = ["input1", "input2", "input3"]
        query = "query"
        OpenAIKey = "OpenAIKey"
        result = gen_for_gpt3(input, query, OpenAIKey)
        assert isinstance(result, list)
        assert all(isinstance(item, str) for item in result)
